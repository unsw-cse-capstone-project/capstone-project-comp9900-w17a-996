'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

require('./styles.css');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var PmRibbon = function (_React$Component) {
    _inherits(PmRibbon, _React$Component);

    function PmRibbon(props) {
        _classCallCheck(this, PmRibbon);

        var _this = _possibleConstructorReturn(this, (PmRibbon.__proto__ || Object.getPrototypeOf(PmRibbon)).call(this, props));

        _this.init = function () {
            _this.ctx.clearRect(0, 0, _this.width, _this.height);
            _this.path = [{ x: 0, y: _this.drawSite[0] }, { x: 0, y: _this.drawSite[1] }];
            // 直至x方向绘制完成
            while (_this.path[1].x < _this.width + _this.ribbonWidth) {
                _this.draw(_this.path[0], _this.path[1]);
            }
        };

        _this.draw = function (start, end) {
            var ctx = _this.ctx; // 获取实例
            ctx.beginPath(); // 开始路径
            ctx.moveTo(start.x, start.y); // 绘制第一点
            ctx.lineTo(end.x, end.y); // 绘制第二点
            var nextX = end.x + (_this.random() * 2 - 0.25) * _this.ribbonWidth; // 随机生成第三点的x坐标
            var nextY = _this.geneY(end.y); // 随机生成第三点的y坐标
            ctx.lineTo(nextX, nextY); // 绘制第三点
            ctx.closePath(); // 闭合本次路径
            ctx.fillStyle = _this.geneStyle(); // 得到随机绘制颜色
            ctx.fill(); // 着色
            _this.r -= _this.PI_2 / -50; // 调整下次的随机颜色
            _this.path[0] = _this.path[1]; // 重新定义第一开始点
            _this.path[1] = { x: nextX, y: nextY // 重新定义第二开始点
            };
        };

        _this.geneStyle = function () {
            var cos = _this.cos;
            var bgStyle = [];
            bgStyle[0] = parseInt(cos(_this.r) * 127 + 128).toString(16);
            bgStyle[1] = parseInt(cos(_this.r + _this.PI_2 / 3) * 127 + 128).toString(16);
            bgStyle[2] = parseInt(cos(_this.r + _this.PI_2 / 3 * 2) * 127 + 128).toString(16);
            bgStyle[0] = bgStyle[0].length === 1 ? '0' + bgStyle[0] : bgStyle[0];
            bgStyle[1] = bgStyle[1].length === 1 ? '0' + bgStyle[1] : bgStyle[1];
            bgStyle[2] = bgStyle[2].length === 1 ? '0' + bgStyle[2] : bgStyle[2];
            return '#' + bgStyle.join('');
        };

        _this.geneY = function (y) {
            var temp = y + (_this.random() * 2 - 1.1) * _this.ribbonWidth;
            // 如果第三点在视图外重新获取
            return temp > _this.height || temp < 0 ? _this.geneY(y) : temp;
        };

        _this.state = {};
        _this.ctx = null;
        _this.ribbonWidth = _this.props.ribbonWidth || 100; // 彩带宽度
        _this.globalAlpha = _this.props.globalAlpha || 0.5; // 彩带透明度 
        _this.zIndex = _this.props.zIndex || 0; // canvas层级
        _this.canClickChange = _this.props.canClickChange || false; // 点击canvas能否变化
        _this.clickChangeDom = _this.props.clickChangeDom || null; // 点击其他部位变化
        _this.r = 0; // 用于控制水随机色
        _this.PI_2 = Math.PI * 2; // 圆周率
        _this.cos = Math.cos; // cos函数
        _this.random = Math.random; // 随机函数
        return _this;
    }

    _createClass(PmRibbon, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var canvasRibbon = this.refs.ribbonCanvas; // 获取canvasDom
            var ctx = canvasRibbon.getContext('2d'); // 获取canvas2d实例
            this.ctx = ctx; // 保存canvas
            this.width = canvasRibbon.offsetWidth; // 当前canvas容器的高
            this.height = canvasRibbon.offsetHeight; // 当前canvas容器的宽
            // 绘制初始位置, 默认中间浮动半个宽度
            this.drawSite = this.props.drawSite || [this.height * 0.5 + this.ribbonWidth, this.height * 0.5 - this.ribbonWidth];
            var dpr = window.devicePixelRatio || 1; // 设备的物理像素分辨率与CSS像素分辨率的比率
            canvasRibbon.width = this.width * dpr; // 实际canvas绘图的宽
            canvasRibbon.height = this.height * dpr; // 实际canvas绘图的宽
            ctx.scale(dpr, dpr); // 实际canvas缩放比
            ctx.globalAlpha = this.globalAlpha; // 设置彩带透明度
            this.init(); // 初始化彩带生成函数
            this.clickChangeDom && this.clickChangeDom.addEventListener('click', this.init); // 监听click事件
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.clickChangeDom && this.clickChangeDom.removeEventListener('click', this.init); // 取消监听click事件
        }

        /** 
         * 初始化彩带函数
        */


        /** 
         * 绘制彩带
        */


        /** 
         * 随机生成并设置canvas路径16进制颜色
        */


        /**
         * 随机生成第三点的位置
         */

    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var style = {
                zIndex: this.zIndex
            };
            return _react2.default.createElement('canvas', { ref: 'ribbonCanvas', className: 'pm-ribbon', onClick: function onClick() {
                    _this2.canClickChange && _this2.init();
                },
                style: _extends({}, style) });
        }
    }]);

    return PmRibbon;
}(_react2.default.Component);

exports.default = PmRibbon;